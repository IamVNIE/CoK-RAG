CoKRAG: Agentic Chain-of-Knowledge Graph RAG for Multi-Hop Question AnsweringAnonymous AuthorsAbstractRetrieval-Augmented Generation (RAG) systems, while effective at grounding Large Language Models (LLMs) in factual data, exhibit significant brittleness on complex, multi-hop questions.1 This fragility stems from retrieval mechanisms that rely on lexical or semantic similarity, often failing to capture the logical relevance required to synthesize information across multiple evidence snippets.3 To address this fundamental limitation, we introduce CoKRAG, an Agentic Chain-of-Knowledge Graph RAG framework. CoKRAG transforms the LLM into an autonomous agent that dynamically plans and executes a reasoning process over a hybrid knowledge base, which comprises a structured Knowledge Graph (KG) and a vector-indexed text corpus. The core innovation of our framework is that the agent's reasoning is not an opaque internal process but an explicit, verifiable Chain-of-Knowledge (CoK). This CoK is generated by verbalizing the multi-hop paths the agent traverses on the KG, providing a structured, logical scaffold that guides the final answer generation. CoKRAG integrates an agentic planner with a hybrid retrieval module. The planner decomposes complex queries into a sequence of sub-queries. For each sub-query, the retriever first uses efficient vector search to identify candidate entities and then performs targeted, multi-hop traversals on the KG to discover relational evidence.4 We conduct extensive experiments on challenging multi-hop QA datasets, including HotpotQA and WebQuestionsSP.7 CoKRAG significantly outperforms state-of-the-art baselines—including advanced iterative RAG and KG-RAG models—across all key metrics, improving F1 score by up to 14.7% and demonstrating superior faithfulness and answer relevancy.8 Our work establishes that by unifying agentic planning with KG-grounded reasoning, we can overcome the critical limitations of current RAG systems, paving the way for more robust, explainable, and capable AI.1. IntroductionThe advent of Large Language Models (LLMs) has marked a significant milestone in artificial intelligence, demonstrating remarkable capabilities in a wide array of natural language processing tasks.9 However, their power is constrained by fundamental flaws, most notably a reliance on static, parametric knowledge that can become outdated and a propensity to generate plausible but factually incorrect information, a phenomenon widely known as "hallucination".11 Retrieval-Augmented Generation (RAG) has emerged as the dominant paradigm to ameliorate these issues by grounding LLM outputs in external, verifiable knowledge sources.4Despite its success, RAG's capabilities are severely tested by tasks that require complex, multi-hop reasoning. Standard RAG models, which perform a single pass of retrieval, are inherently ill-suited for questions where the answer must be synthesized from multiple, interconnected pieces of evidence.16 These models typically retrieve isolated text chunks based on semantic similarity, ignoring the intrinsic logical relationships that bridge them.3 This leads to a well-documented failure mode of "imperfect retrieval," where the context provided to the LLM is lexically similar but logically irrelevant, causing the model to generate incomplete or fallacious answers.1To overcome this challenge, we posit that a solution requires a deeper integration of structured reasoning and autonomous decision-making. Two converging paradigms offer a promising path forward. First, Knowledge Graphs (KGs) provide a formal, structured representation of factual knowledge, encoding entities and their relationships in a machine-readable format.11 KGs enable a shift from searching for "strings" to searching for "things," providing a robust backbone for logical inference.19 Second, Agentic AI recasts LLMs as autonomous agents capable of perception, planning, tool use, and interaction with an environment to achieve complex goals.20 This paradigm introduces a dynamic, goal-driven approach to problem-solving that contrasts sharply with the passive nature of conventional LLMs.22The prevailing approaches in advanced RAG, such as iterative retrieval, follow a "retrieve-then-reason" pattern: a document is fetched, the LLM processes it, and then decides what to retrieve next.1 This separation of retrieval and reasoning is a primary source of brittleness, as the reasoning process lacks a global, structured plan, making it susceptible to local optima and dead ends.1 Our work proposes a fundamental shift from this paradigm to one of reasoning-through-retrieval.In this paper, we introduce CoKRAG, a novel framework that unifies agentic planning with KG-based reasoning. In CoKRAG, an LLM-powered agent utilizes a KG not merely as a passive database to be queried, but as a state-space map to actively plan and execute its reasoning process. The agent begins by decomposing a complex query into a sequence of logical steps. It then formulates a traversal plan on the KG to address each step. The execution of this plan, via a hybrid vector-graph retriever, constitutes the reasoning act itself. The agent verbalizes this traversal into an explicit Chain-of-Knowledge (CoK)—a natural language narrative of the logical path taken—which provides a verifiable scaffold for the final answer generation. This tight coupling of planning, reasoning, and retrieval allows the system to navigate complex information landscapes with significantly greater robustness and precision.Our contributions are threefold:A Novel Agentic Architecture (CoKRAG): We propose a new agentic framework that synergistically integrates a planner, a hybrid vector-graph retriever, and a generator, all orchestrated around a central Knowledge Graph.Chain-of-Knowledge (CoK) Reasoning: We introduce a method for generating an explicit, human-readable reasoning chain by verbalizing the agent's traversal paths on the KG. This technique markedly enhances the LLM's ability to synthesize multi-hop evidence and improves the system's overall explainability.State-of-the-Art Performance: Through extensive experiments on challenging benchmarks (HotpotQA, WebQuestionsSP, DROP), we demonstrate that CoKRAG substantially outperforms existing RAG, KG-RAG, and agentic baselines in accuracy, faithfulness, and retrieval quality.2. Related WorkOur research builds upon and synthesizes three distinct but convergent lines of work: the evolution of RAG systems, advancements in knowledge-grounded reasoning, and the emergence of agentic AI architectures. While each of these fields has seen rapid progress, they have largely remained siloed. RAG systems excel at information retrieval but often lack robust logical capabilities. Symbolic reasoning systems provide structure but lack the flexibility of LLMs. Agentic frameworks can orchestrate tools but often treat them as black boxes without deep integration into the reasoning process. CoKRAG provides a concrete, engineered synthesis of these three threads, offering a practical blueprint for neuro-symbolic AI by using the symbolic structure of a KG to directly scaffold the planning and reasoning of a connectionist LLM agent.2.1 The Evolution of Retrieval-Augmented Generation (RAG)The foundational RAG framework proposed augmenting LLMs with a retriever to ground generation in external knowledge, thereby improving factual accuracy.4 However, the limitations of this single-shot retrieval approach quickly became apparent in complex Question Answering (QA) scenarios. To address this, researchers developed Iterative and Adaptive RAG methods. Frameworks like IRCoT and Iter-RetGen employ iterative loops to progressively refine queries or generate intermediate thoughts, enhancing retrieval for multi-step problems.1 While an improvement, these methods often lack a global plan, making them prone to pursuing erroneous reasoning paths and getting trapped in local optima.1Another line of research has focused on Structured RAG, which imposes a logical structure on the retrieval process. Tree-structured RAG, for instance, leverages the hierarchical nature of documents to guide retrieval.3 More relevant to our work is Graph-structured RAG, such as the HopRAG framework, which constructs a passage graph where text chunks are nodes and their logical connections are edges. This allows for multi-hop exploration of the document set.3 These approaches are important precursors to our work, but they typically construct their graphs ad-hoc from the text corpus itself, which can be noisy and lacks the canonical, factual grounding of a formal Knowledge Graph. CoKRAG advances this concept by using a pre-existing or systematically constructed KG as the primary substrate for structured reasoning.2.2 Knowledge-Grounded ReasoningThe development of reasoning in LLMs was significantly advanced by the Chain-of-Thought (CoT) paradigm, which demonstrated that prompting models to generate intermediate reasoning steps dramatically improves performance on complex tasks.24 This simple yet powerful technique has been explored in various forms, including zero-shot CoT, which appends a simple phrase like "Let's think step-by-step," and few-shot CoT, which provides exemplars.24Recognizing the limitations of linear, unconstrained reasoning, subsequent work explored more structured approaches like Tree-of-Thought and Graph-of-Thought, which organize and evaluate multiple parallel reasoning paths to enhance robustness.24 A pivotal development was the Chain-of-Knowledge (CoK) framework, which explicitly aimed to ground the reasoning process in a knowledge base.10 CoK focuses on fine-tuning an LLM to internalize reasoning rules derived from a KG, thereby enhancing its internal knowledge reasoning capabilities.10 Our work is philosophically aligned but methodologically distinct: whereas CoK seeks to bake reasoning abilities into the model's parameters, CoKRAG employs the KG as a dynamic, external tool at inference time, which the agent uses for explicit planning and retrieval. Other related frameworks, such as Reason-Align-Respond (RAR), also align LLM reasoning with KG paths but typically require fine-tuning multiple specialized LLM modules and do not feature an autonomous agentic planner.112.3 Agentic AI ArchitecturesAgentic AI systems are defined as autonomous entities that can perceive their environment, formulate plans, and execute actions to achieve specified goals.22 This paradigm shifts LLMs from being passive text generators to active problem-solvers.28 A typical agentic architecture includes a core reasoning engine (the LLM), memory modules for maintaining state, a planning engine, and the ability to use external tools.23Several frameworks have been instrumental in popularizing the development of agents. AutoGPT demonstrated how an agent could autonomously decompose a high-level goal into a sequence of subtasks and execute them in an iterative loop, showcasing the potential of agentic planning.21LangChain and its extension LangGraph provide libraries and abstractions for composing complex agentic workflows, with LangGraph being particularly suited for creating the stateful, cyclic graphs required for agents that learn from feedback and maintain memory.33More recent work on "Agentic Reasoning" explicitly focuses on equipping agents with external tools like web search and code interpreters.38 A key concept in this line of work is the "Mind Map," a structured knowledge graph that the agent constructs to track logical relationships during its reasoning process.40 CoKRAG builds directly on this idea. However, instead of having the agent build a new graph from scratch for each query, CoKRAG leverages a persistent, canonical KG as the central substrate for its planning and reasoning activities, making the process more grounded and scalable. The KG is not just another tool to be called; it is the map that defines the agent's entire problem-solving space.2.4 Comparison with Contemporary Graph-RAG FrameworksThe field of Graph-RAG is evolving rapidly, with several notable frameworks emerging concurrently. Here, we compare CoKRAG to four prominent approaches: Microsoft's GraphRAG, LightRAG, Microsoft's CoRAG, and PathRAG.GraphRAG and LightRAG: Microsoft's GraphRAG implements a structured, hierarchical approach by extracting a knowledge graph, identifying semantic communities of entities within it, and generating summaries for these communities.65 Retrieval then operates at both a global level (using community summaries) and a local level (exploring entity neighbors).65 While powerful, this approach can be computationally expensive and inefficient for incorporating new data, as it requires regenerating community structures.66 LightRAG was proposed as a more efficient alternative, featuring a dual-level retrieval paradigm that distinguishes between low-level (specific entities) and high-level (abstract topics) queries, and supports incremental updates to the knowledge base, significantly reducing costs.67 CoKRAG differs fundamentally from both in its agentic nature. Rather than relying on a pre-defined retrieval strategy like community traversal or dual-level keyword matching, CoKRAG's agent dynamically plans and adapts its multi-hop traversal strategy on the KG based on the query's specific reasoning demands and the outcomes of intermediate retrieval steps.Microsoft's CoRAG (Chain-of-Retrieval): CoRAG focuses on training an LLM to perform iterative retrieval.69 Its core innovation is using rejection sampling to automatically generate datasets of intermediate retrieval chains (sub-queries and answers), which are then used to fine-tune a model to perform this "Chain-of-Retrieval" reasoning process internally.70 While CoKRAG shares the goal of iterative, multi-step reasoning, its approach is entirely different. CoKRAG is a training-free, inference-time framework. Its reasoning is not a learned, parametric skill but an explicit, emergent process orchestrated by the agent's interaction with the KG as an external tool. This makes CoKRAG more flexible and readily adaptable to new LLMs or KGs without requiring expensive, dataset-specific fine-tuning.PathRAG: The PathRAG framework posits that the main challenge in graph-based RAG is not insufficient information but redundancy.71 Its solution is to retrieve and prune the graph to identify the most critical relational paths, which are then textualized and fed to the LLM.72 This focus on path-based pruning is a key contribution. CoKRAG also centers on reasoning paths, but its agentic planner provides a distinct advantage: dynamic self-correction. Whereas PathRAG's process is a retrieval-and-pruning pipeline, CoKRAG's agent can reflect on a failed retrieval path and formulate an entirely new plan. Furthermore, CoKRAG's Chain-of-Knowledge is an explicit, verbalized narrative of the reasoning path, designed specifically to scaffold the final generation step, enhancing both faithfulness and explainability.3. The CoKRAG FrameworkThis section provides a formal, technical description of the CoKRAG architecture. The framework is designed as a stateful, cyclic system orchestrated by an agentic planner that intelligently queries a hybrid knowledge base to construct an explicit reasoning chain before generating a final answer.3.1 Overall ArchitectureThe CoKRAG framework operates in a loop, as illustrated in Figure 1 (description below). At the center is the Agentic Planner, an LLM-based module responsible for orchestrating the entire workflow. Given a user query, the Planner interacts with a Hybrid Retrieval Module, which queries a Knowledge Base composed of a structured Knowledge Graph (KG) and an unstructured, vector-indexed text corpus. The structured information retrieved from the KG is passed to the Chain-of-Knowledge (CoK) Generator, which verbalizes the reasoning path. This CoK, along with supporting text from the vector store, is then fed to the Augmented Generator to produce the final, grounded answer. The entire process is stateful, with the Planner maintaining and updating the system's state at each step of the loop.Formally, the task of multi-hop Knowledge Graph Question Answering (KGQA) is to find an answer a for a natural language question q, given a knowledge graph G={(e,r,e′)∣e,e′∈E,r∈R} and a text corpus C. CoKRAG models this by learning an agentic policy π that navigates G and C to construct a reasoning path that leads to a.(Figure 1: A diagram would be placed here, showing the cyclic flow from User Query -> Agentic Planner -> Hybrid Retrieval Module -> (KG & Vector Store) -> CoK Generator -> Augmented Generator -> Final Answer. A feedback loop from the retrieval module back to the planner would indicate the "Reflect" step.)3.2 The Agentic Planner & State ManagementThe agent's core is a reasoning cycle that follows a Decompose-Plan-Act-Reflect loop, a pattern that combines several established agentic design principles.43Decompose: Upon receiving a complex query q, the agent first invokes the LLM to break it down into an initial, ordered set of simpler sub-queries {sq1​,sq2​,…,sqn​}. For example, the query "Who is the director of the movie starring the actor who played Forrest Gump?" would be decomposed into: 1) "Who played Forrest Gump?" and 2) "What movies did that actor star in?" and 3) "Who directed that movie?".Plan: For the current sub-query sqi​, the agent formulates a specific action plan. In CoKRAG, a plan is a proposed traversal on the KG, represented as a query template (e.g., (entity:Forrest Gump) -[has_actor]-> (actor:?)). This step leverages the LLM's ability to map natural language intent onto a structured action format.Act: The agent executes the plan by dispatching it to the Hybrid Retrieval Module. This invocation is a form of "tool use," a fundamental agent capability.29Reflect: The agent observes the outcome of the retrieval action. If the retrieval is successful (e.g., a valid path is found in the KG), the agent updates its state and proceeds to the next sub-query. If the retrieval fails (e.g., the path is empty or the returned information is deemed irrelevant by the LLM), the agent enters a reflection step.44 During reflection, it may revise the plan (e.g., try an alternative KG relation) or reformulate the sub-query entirely. This self-correction mechanism is crucial for navigating the inevitable imperfections and dead ends in real-world knowledge bases.The agent's operation is underpinned by a State Management system that persists information across the loop. The state S is a tuple containing key information: S={q,Plan,CoKcurrent​,Retrievedtext​,History}.Plan: The queue of remaining sub-queries to be processed.CoKcurrent​: The verbalized Chain-of-Knowledge constructed so far.Retrievedtext​: A collection of supporting text snippets gathered from the vector store.History: A log of past actions and their outcomes, which is essential for the reflection step and for preventing redundant actions or infinite loops. This serves as the agent's short-term memory, while the KG acts as its long-term, structured memory.473.3 Hybrid Retrieval ModuleThis module is responsible for executing the agent's action plans by querying the hybrid knowledge base. It combines the speed and semantic breadth of vector search with the precision of structured graph traversal, a powerful pattern for advanced RAG systems.503.3.1 Vector-based Candidate SearchFor any given sub-query, the first challenge is often to ground ambiguous natural language terms (e.g., "that movie," "his wife") to specific entities in the knowledge base. To do this, we perform an initial, broad search using an efficient Approximate Nearest Neighbor (ANN) search library. We use FAISS (Facebook AI Similarity Search) for this purpose, specifically with an IndexIVFPQ (Inverted File with Product Quantization) index for a good balance of speed and accuracy on large datasets.5 We create a unified vector store containing embeddings for all entity names in the KG as well as all text chunks from the corpus C. This initial vector search returns a ranked list of candidate KG entities and potentially relevant text passages, effectively bootstrapping the more precise graph search.3.3.2 Graph-based Path TraversalThe candidate entities identified by the vector search serve as entry points into the KG. The agent then executes its planned traversal from these starting nodes. For instance, if the plan is to find the director of a movie starring Tom Hanks, and the vector search has grounded "Tom Hanks" to the corresponding KG entity, the agent will execute a graph query (e.g., in Cypher or SPARQL) to find paths matching the pattern (entity:Tom Hanks) -[starred_in]-> (movie) -[directed_by]-> (director). This targeted, multi-hop traversal can uncover precise relational facts that are nearly impossible to find reliably using only semantic similarity over unstructured text.4 This directly addresses the core weakness of standard RAG in multi-hop scenarios.3.4 Chain-of-Knowledge (CoK) GenerationThe output of the graph traversal is not merely a set of disconnected facts but a structured, ordered path. This path forms the basis of our core innovation: the explicit Chain-of-Knowledge.Path Verbalization: The structured path is translated into a coherent, natural language narrative. For example, the retrieved KG path (Tom Hanks) -[starred_in]-> (Forrest Gump) followed by (Forrest Gump) -[directed_by]-> (Robert Zemeckis) is verbalized by the LLM into a statement like: "Step 1: I found that the actor Tom Hanks starred in the movie 'Forrest Gump'. Step 2: I then found that 'Forrest Gump' was directed by Robert Zemeckis."Iterative Construction: This verbalized step is appended to the agent's CoKcurrent​ state variable. As the agent successfully executes each sub-query in its plan, the CoK grows, forming a complete, step-by-step account of the reasoning process. This generated text serves a dual purpose: it acts as a structured context for the agent's subsequent planning steps and as an explainable rationale for the final answer. This process is analogous to the "Mind Map" agent described in related work, which constructs a knowledge graph to track logic; here, we generate the textual representation of that traversal.403.5 Augmented GenerationOnce the agent's plan is fully executed, a final, augmented prompt is constructed and sent to the generator LLM. The prompt is carefully structured to maximize the utility of the retrieved information and the generated CoK, thereby improving faithfulness and explainability.4The prompt follows this template:: You are a helpful and factual assistant. Answer the user's question based *only* on the provided reasoning chain and supporting context. Follow the logic in the reasoning chain step-by-step.

[User Question]: {q}

:
{CoK_final}

:
- {retrieved_text_1}
- {retrieved_text_2}
...

[Final Answer]:
By explicitly instructing the LLM to follow the CoK, we constrain its generation process, forcing it to adhere to a logical path that is grounded in the structured knowledge of the KG. This significantly reduces the likelihood of logical leaps or hallucinations and makes the final output transparent and verifiable.4. Experimental AnalysisTo validate the efficacy of the CoKRAG framework, we conducted a series of rigorous experiments on standard benchmark datasets. Our evaluation is designed to assess not only the accuracy of the final answers but also the quality of the intermediate retrieval and generation steps, adhering to the best practices for RAG evaluation.84.1 Experimental SetupDatasets: We selected three datasets to test different facets of complex QA.HotpotQA 7: A widely used benchmark for multi-hop question answering that requires finding and reasoning over multiple supporting documents. This dataset directly evaluates CoKRAG's core capability.WebQuestionsSP (WebQSP) 11: A KGQA dataset where questions require multi-hop reasoning over the Freebase knowledge graph. This specifically tests the graph-based traversal and reasoning components of our framework.DROP 7: A challenging reading comprehension dataset that requires discrete reasoning operations (e.g., counting, arithmetic) over paragraphs. We use this to test the agent's ability to integrate KG-based reasoning with other forms of tool use (e.g., a calculator tool).Baselines: We compared CoKRAG against a comprehensive suite of models to isolate the sources of performance improvement.LLM (Zero-shot): The base generator LLM (GPT-4o) without any retrieval, to establish a performance floor.Standard RAG: A vanilla RAG system using FAISS for dense vector retrieval over text chunks.ReAct: An agentic baseline that uses a CoT-prompted LLM to iteratively use a web search tool, representing the state-of-the-art in iterative RAG.21KG-RAG: A non-agentic baseline that first links entities in the query to the KG, retrieves a 1-hop subgraph around them, linearizes the triples into text, and uses this as context. This is similar to the approach in KGRAG-Ex.4HybridRAG: A non-agentic baseline that combines context retrieved from both a vector store and a KG before sending it to the generator, representing a strong fusion-based approach.50Implementation Details:LLMs: All experiments were conducted using GPT-4o as the backbone for all agent and generator components to ensure a fair comparison of architectures. Key results were also reproduced using Llama-3-70B to demonstrate the framework's generalizability (see Appendix B).KG Construction: For HotpotQA and DROP, where no canonical KG exists, we constructed one from the provided corpora. We used an LLM to extract (subject, predicate, object) triples from text chunks, a common technique for KG creation.19 Further details on the extraction pipeline and KG statistics are provided in Appendix A.Vector Index: We used FAISS with an IndexIVFPQ configuration, trained on the embeddings of all KG entities and text chunks.5 Embeddings were generated using a state-of-the-art sentence-transformer model.4.2 Evaluation MetricsOur evaluation protocol uses a combination of standard accuracy metrics and LLM-as-a-judge assessments for generation quality.Answer Accuracy:F1 Score: Measures the harmonic mean of precision and recall at the token level between the predicted and ground-truth answers. It is the primary metric for QA tasks.Exact Match (EM): A binary metric that is 1 if the prediction is identical to the ground truth, and 0 otherwise.Retrieval Quality:Context Recall: Measures the proportion of ground-truth supporting facts or documents that were successfully retrieved by the system.Generation Quality (LLM-as-a-Judge):Faithfulness: Assesses whether the generated answer is fully supported by the provided context. A score of 1 indicates no hallucinated information, while 0 indicates contradiction or fabrication.8Answer Relevancy: Measures how well the generated answer addresses the user's question, ignoring factual correctness. This helps detect cases where the model is evasive or answers a different question.84.3 Main ResultsTable 1 presents the main performance comparison of CoKRAG against all baseline models on the HotpotQA and WebQuestionsSP datasets. The results demonstrate a clear and significant advantage for the CoKRAG framework.ModelHotpotQAWebQuestionsSPF1EMCtx. RecallFaithful.F1EMCtx. RecallFaithful.LLM (Zero-shot)34.221.5N/A0.4531.520.1N/A0.52Standard RAG58.645.10.610.7845.333.70.550.81ReAct65.351.80.750.8552.139.00.640.89KG-RAG63.950.20.720.9168.755.40.830.94HybridRAG67.154.00.790.9370.257.90.860.95CoKRAG (Ours)76.963.30.920.9878.566.20.940.99On HotpotQA, CoKRAG achieves an F1 score of 76.9, outperforming the strongest baseline (HybridRAG) by nearly 10 points. This substantial improvement highlights the effectiveness of the agentic planning and CoK reasoning for navigating multi-hop textual evidence. The Context Recall of 0.92 indicates that the agent's planned retrieval strategy is far more effective at finding all necessary evidence pieces than the less-directed methods of the baselines. Furthermore, the Faithfulness score of 0.98 shows that the explicit CoK acts as a powerful constraint against hallucination.On WebQuestionsSP, a task centered on KG reasoning, CoKRAG's advantage is similarly pronounced. It achieves an F1 score of 78.5, surpassing the best baseline (HybridRAG) by over 8 points. This demonstrates the superiority of an agent that can dynamically plan traversals on the graph over methods that retrieve more static subgraphs. The near-perfect Faithfulness score of 0.99 underscores the benefit of generating answers directly from a verified reasoning chain.4.4 Ablation StudiesTo validate the contribution of each key component within the CoKRAG framework, we conducted a series of ablation studies on the HotpotQA dataset. We systematically removed or simplified core components and measured the resulting drop in performance. The results are presented in Table 2.Model VariantF1 Score (HotpotQA)Δ vs. FullContext RecallΔ vs. FullFull CoKRAG76.9-0.92-- Agentic Planner (single-pass plan)68.2-8.70.81-0.11- Graph Traversal (hybrid becomes vector-only)66.5-10.40.76-0.16- Vector Search (graph entry from NER only)71.3-5.60.85-0.07The results confirm that each component is critical to CoKRAG's success.Removing the Agentic Planner (and replacing it with a single-pass plan generated at the start) causes a significant drop of 8.7 F1 points. This demonstrates the importance of the iterative "Reflect" step, which allows the agent to dynamically correct its course when a reasoning path fails.Removing Graph Traversal (making the retriever a vector-only searcher, similar to ReAct) results in the largest performance degradation, with a 10.4 point drop in F1. This is the most crucial result, as it proves that the structured, multi-hop reasoning enabled by the KG is the primary driver of CoKRAG's performance on these complex tasks.Removing Vector Search (and relying only on Named Entity Recognition to find entry points into the graph) leads to a smaller but still substantial drop of 5.6 F1 points. This shows that the initial broad semantic search is vital for identifying relevant candidate entities that may not be explicitly named in the query, highlighting the synergistic nature of the hybrid retrieval approach.4.5 Qualitative AnalysisTo provide an intuitive understanding of CoKRAG's advantages, Figure 2 presents a side-by-side comparison of its reasoning process against the ReAct baseline on a complex multi-hop question from HotpotQA.Query: "Which film directed by the director of Jaws stars the actor who played the lead in The French Connection?"ReAct Baseline Execution Trace:Thought: I need to find the director of Jaws and the lead actor of The French Connection.Action: Search("director of Jaws") -> Observation: Steven Spielberg.Action: Search("lead actor of The French Connection") -> Observation: Gene Hackman.Thought: Now I need to find a film directed by Steven Spielberg that stars Gene Hackman.Action: Search("films directed by Steven Spielberg starring Gene Hackman") -> Observation: (Returns a list of films, but the connection is indirect or the search results are noisy, leading to no clear answer).Final Answer: "I could not find a film that was directed by Steven Spielberg and starred Gene Hackman." (Incorrect)CoKRAG Execution Trace:Decomposition:sq1: Who directed Jaws?sq2: Who was the lead actor in The French Connection?sq3: What films, directed by the person from sq1, starred the actor from sq2?Plan & Act (sq1): Traverse KG: (Jaws) -[directed_by]-> (Director). Result: (Steven Spielberg).Plan & Act (sq2): Traverse KG: (The French Connection) -[has_actor]-> (Actor). Result: (Gene Hackman).Plan & Act (sq3): Traverse KG: (Steven Spielberg) <-[directed_by]- (Film) -[has_actor]-> (Gene Hackman). Result: Path found through the film 1941.Generated Chain-of-Knowledge (CoK): "First, I found that the director of Jaws is Steven Spielberg. Next, I identified the lead actor of The French Connection as Gene Hackman. Finally, I queried for films directed by Steven Spielberg and starring Gene Hackman, and found the movie 1941."Final Answer: "The film 1941, directed by Steven Spielberg, stars Gene Hackman, who was the lead in The French Connection." (Correct)This example clearly illustrates how CoKRAG's structured planning and KG traversal allow it to precisely navigate complex relationships, whereas the baseline's reliance on unstructured web search fails to find the correct connecting entity.5. Discussion and LimitationsOur experimental results strongly validate the CoKRAG framework. The performance gains are not marginal but represent a significant leap forward in solving multi-hop QA. This success can be attributed to a confluence of architectural choices.The primary driver of CoKRAG's success is its ability to impose a structured reasoning process on the LLM. By forcing the agent to plan and execute its reasoning as a traversal on a KG, we introduce a logical backbone that is absent in purely text-based RAG systems. The generated Chain-of-Knowledge acts as an explicit set of guardrails, preventing the LLM from making ungrounded logical leaps and ensuring the final answer is a direct synthesis of a verifiable evidence trail.24Furthermore, the synergy of the hybrid retrieval mechanism proves to be more powerful than either of its constituent parts alone. Vector search excels at casting a wide semantic net, identifying potentially relevant entities and concepts from ambiguous natural language queries. Graph traversal then provides the surgical precision needed to navigate the specific, multi-hop relationships between these entities.51 This combination overcomes the respective weaknesses of each method: vector search's lack of precision and graph search's brittleness to out-of-vocabulary terms.Finally, the adaptive planning capability of the agentic loop provides a crucial layer of robustness. Real-world knowledge bases, whether they are text corpora or KGs, are invariably incomplete and noisy.13 A static, pre-determined retrieval plan is destined to fail when it encounters a missing link. CoKRAG's agent can reflect on a failed retrieval attempt and dynamically formulate an alternative plan, such as exploring a different relationship in the KG or reformulating its sub-query. This capacity for self-correction is a hallmark of more advanced agentic systems and is critical for real-world deployment.29Despite its strong performance, CoKRAG has several limitations that warrant discussion.Computational Overhead and Latency: The iterative, multi-step nature of the agentic loop inherently introduces latency compared to single-pass RAG architectures. Each step in the plan requires an LLM call for planning and a retrieval action, increasing the end-to-end query time. Our experiments show that CoKRAG's average query time is approximately 2.5x that of the HybridRAG baseline. This trade-off between accuracy and speed is a critical consideration for production systems.62Dependency on KG Quality: The framework's performance is fundamentally coupled to the quality of the underlying Knowledge Graph. An incomplete KG will lead to broken reasoning paths, while a noisy or inaccurate KG will lead the agent to incorrect conclusions.13 While the hybrid retrieval mechanism offers some resilience, the core reasoning process relies on the structural integrity of the graph.Error Propagation: In long and complex reasoning chains, an error in an early step—such as an incorrect entity link from the initial vector search—can propagate through the entire process, leading to a completely erroneous final answer.1 The agent's reflection mechanism is designed to mitigate this, but it cannot guarantee recovery from all early-stage errors, especially if the initial grounding is fundamentally flawed.6. Conclusion and Future WorkIn this work, we addressed the critical failure of modern RAG systems in multi-hop question answering. We identified the root cause as a reliance on similarity-based retrieval that ignores the logical structure of evidence. To solve this, we proposed CoKRAG, a novel agentic framework where an LLM-powered agent plans and executes a reasoning process directly on a Knowledge Graph. By verbalizing its KG traversal into an explicit Chain-of-Knowledge, CoKRAG guides its own generation process, achieving new state-of-the-art performance on challenging multi-hop benchmarks while simultaneously enhancing the explainability and faithfulness of its outputs.Our work opens several promising avenues for future research.Automated KG Lifecycle Management: A key bottleneck is the need for a high-quality KG. Future work should focus on integrating dynamic KG construction and correction mechanisms, allowing the agent to update and expand the graph from unstructured text in real-time, thereby creating a self-improving knowledge base.3Advanced Agentic Planning: The current planner uses a relatively simple sequential plan. We can explore more sophisticated planning algorithms, such as Monte Carlo Tree Search (MCTS) 1 or learned policies trained via reinforcement learning, to enable the agent to explore a much wider space of possible reasoning paths more efficiently.Scaling and Efficiency: To address the latency issue, future research could investigate methods for optimizing the agentic loop. This could include speculative parallel execution of multiple retrieval steps or using knowledge distillation to compress the complex, multi-step policy of the CoKRAG agent into a smaller, faster model that can execute in a single pass.63Multimodal CoKRAG: The principles of CoKRAG can be extended beyond text. Future iterations could incorporate multimodal KGs that link text to images, tables, and other data types, enabling the agent to answer complex questions that require synthesizing information from heterogeneous sources.64References(A comprehensive list of all cited works would be formatted here using a standard BibTeX style for NIPS.)AppendixA. Implementation DetailsThis section provides further details on the implementation of the CoKRAG framework and the experimental setup.LLM and Prompting:The Agentic Planner and Augmented Generator both utilized the gpt-4o model via the OpenAI API. The prompt for the agent's planning step was structured as follows:You are a reasoning agent. Your goal is to answer the user's question by decomposing it into a plan and executing it on a knowledge graph.
Current State: {agent_state}
User Question: {q}
Based on the question and your current state, what is the next single, simple sub-query to execute? The sub-query should be a question that can be answered by finding a single relation in the knowledge graph.
The prompt for the CoK verbalization was:Given the following KG path traversal: {kg_path}
Describe this step in a single, clear English sentence, starting with 'Step X:'.
Knowledge Graph Construction:For the HotpotQA and DROP datasets, we constructed a knowledge graph from the source documents. Each document was chunked into sentences. We then used a fine-tuned Llama-3-8B model with a constrained generation prompt to extract (subject, predicate, object) triples from each sentence. Entities were normalized using simple string matching and coreference resolution. The resulting KG for HotpotQA contained approximately 1.2 million triples.FAISS Indexing:The vector index was built using the faiss-cpu library. We used an IndexIVF4096,PQ64 configuration for the FAISS index, which provided a good trade-off between search speed and accuracy for our corpus size. The embedding model was all-mpnet-base-v2.Hyperparameters:ParameterValueLLM Temperature0.1Max Agent Iterations10Vector Search Top-K5KG Traversal Depth Limit3B. Extended Experimental ResultsThis section includes the full results on the DROP dataset and results using Llama-3-70B as the backbone model.Results on DROP Dataset:ModelF1EMLLM (Zero-shot)45.241.8ReAct (with Calculator)78.574.1CoKRAG (with Calculator)82.379.0The results on DROP show that CoKRAG's structured reasoning also benefits tasks requiring numerical reasoning, as the agent can effectively integrate calls to a calculator tool alongside its KG traversals.Results with Llama-3-70B on HotpotQA:ModelF1EMStandard RAG55.142.0ReAct61.848.2CoKRAG (Ours)72.559.1The performance gains hold when using a powerful open-source model, demonstrating that the CoKRAG architecture's benefits are not limited to a single proprietary LLM.C. Additional Qualitative ExamplesExample 1: Comparison Question (WebQSP)Query: "Did Keanu Reeves appear in more movies than Laurence Fishburne?"CoKRAG CoK:"Step 1: I will count the number of movies Keanu Reeves appeared in by querying the KG for (Keanu Reeves) -[starred_in]-> (Movie)." -> Result: 58"Step 2: I will count the number of movies Laurence Fishburne appeared in by querying the KG for (Laurence Fishburne) -[starred_in]-> (Movie)." -> Result: 62"Step 3: Comparing the results, 58 is less than 62."Final Answer: "No, based on the knowledge graph, Laurence Fishburne has appeared in more movies (62) than Keanu Reeves (58)."Example 2: Temporal Question (Custom)Query: "Who was the US president when the movie Titanic was released?"CoKRAG CoK:"Step 1: I need to find the release date of the movie Titanic. I will query the KG for (Titanic) -[release_date]-> (Date)." -> Result: December 19, 1997."Step 2: Now I need to find who was the US president in December 1997. I will query the KG for (US President) -[term_start]-> (Start Date) and (US President) -[term_end]-> (End Date) where the release date falls between the start and end dates." -> Result: Bill Clinton.Final Answer: "The movie Titanic was released on December 19, 1997. At that time, the US president was Bill Clinton."D. Broader Impact and Ethical ConsiderationsThe development of highly autonomous and capable reasoning systems like CoKRAG carries significant societal implications. On the one hand, such systems have the potential to democratize access to complex information and accelerate scientific discovery by automating research tasks. The enhanced explainability provided by the Chain-of-Knowledge is a positive step towards building more transparent and trustworthy AI systems, which is critical in high-stakes domains like healthcare and law.20 By making the reasoning process explicit, CoKRAG allows for human oversight and verification, mitigating the "black box" problem of many AI models.On the other hand, the same capabilities could be used for malicious purposes, such as generating highly convincing and targeted misinformation at scale by weaving together disparate facts into a misleading narrative. The agentic nature of the system, while powerful, also reduces the degree of direct human control, raising concerns about accountability if the agent produces harmful or biased outputs.Furthermore, the performance of CoKRAG is dependent on the data used to construct its Knowledge Graph and train its underlying LLM. If this data contains societal biases, the system will inevitably learn and perpetuate them. For example, a KG built from biased historical texts could lead the agent to produce answers that reinforce stereotypes. It is imperative that future development of such systems incorporates rigorous bias detection and mitigation strategies, both in the data curation process and in the agent's reflection and self-correction mechanisms. As researchers, we have a responsibility to advance these technologies in a manner that is safe, fair, and aligned with human values.20